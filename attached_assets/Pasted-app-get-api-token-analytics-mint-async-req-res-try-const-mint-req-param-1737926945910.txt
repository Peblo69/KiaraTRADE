app.get('/api/token-analytics/:mint', async (req, res) => {
  try {
    const { mint } = req.params;
    console.log(`[Routes] Getting analytics for token ${mint}`);

    // 1. Get Basic Token Info and Transfers
    const [tokenResponse, transfersResponse] = await Promise.all([
      axios.post(HELIUS_RPC_URL, {
        jsonrpc: '2.0',
        id: 'token-info',
        method: 'getAsset',
        params: [mint]
      }),
      axios.post(HELIUS_RPC_URL, {
        jsonrpc: '2.0',
        id: 'transfers',
        method: 'searchAssets',
        params: {
          ownerAddress: mint,
          limit: 100,
          page: 1,
          displayOptions: {
            showUnverifiedCollections: true,
            showZeroBalance: true
          }
        }
      })
    ]);

    console.log('[Routes] Token Info Response:', tokenResponse.data);
    console.log('[Routes] Transfers Response:', transfersResponse.data);

    const tokenInfo = tokenResponse.data.result;
    // FIXED: Correct path to transfers array
    const transfers = transfersResponse.data.result?.items || [];

    // 2. Process transfers to identify holders and snipers
    const holders = new Map();
    const snipers = new Set();
    const trades = [];
    const creationTime = transfers.length > 0 ? 
      transfers[transfers.length - 1]?.blockTime || Date.now() : 
      Date.now();
    const sniperWindow = 30000; // 30 seconds

    console.log('[Routes] Processing transfers:', transfers.length);

    // FIXED: Added safety check before processing transfers
    if (transfers.length > 0) {
      transfers.forEach((transfer: any) => {
        const { fromUserAccount, toUserAccount, amount, blockTime } = transfer;

        if (fromUserAccount) {
          const currentFromBalance = holders.get(fromUserAccount) || 0;
          holders.set(fromUserAccount, currentFromBalance - amount);
        }

        if (toUserAccount) {
          const currentToBalance = holders.get(toUserAccount) || 0;
          holders.set(toUserAccount, currentToBalance + amount);

          if (blockTime - creationTime <= sniperWindow) {
            snipers.add({
              address: toUserAccount,
              amount,
              timestamp: blockTime
            });
          }
        }

        trades.push({
          type: fromUserAccount ? 'sell' : 'buy',
          amount,
          timestamp: blockTime,
          address: fromUserAccount || toUserAccount
        });
      });
    }

    console.log('[Routes] Holders processed:', holders.size);
    console.log('[Routes] Snipers detected:', snipers.size);

    // 3. Calculate metrics
    const holderMetrics = calculateHolderMetrics(holders);
    const snipersArray = Array.from(snipers);
    const topHolders = getTopHolders(holders, 10);

    // 4. Prepare response
    // FIXED: Updated token data structure to match API response
    const analytics = {
      token: {
        address: mint,
        name: tokenInfo.content?.metadata?.name || 'Unknown',
        symbol: tokenInfo.content?.metadata?.symbol || 'Unknown',
        decimals: tokenInfo.token_info?.decimals || 0,
        supply: tokenInfo.token_info?.supply || 0,
        mintAuthority: tokenInfo.authorities?.find((a: any) => a.type === 'mint')?.address || null,
        freezeAuthority: tokenInfo.authorities?.find((a: any) => a.type === 'freeze')?.address || null,
        mutable: tokenInfo.mutable || false
      },
      holders: {
        total: holderMetrics.totalHolders,
        unique: holderMetrics.uniqueHolders,
        top10: topHolders,
        concentration: {
          top10Percentage: topHolders.reduce((sum, h) => sum + h.percentage, 0)
        },
        distribution: holderMetrics.distribution
      },
      snipers: {
        total: snipersArray.length,
        details: snipersArray,
        volume: calculateSniperVolume(snipersArray),
        averageAmount: calculateAverageAmount(snipersArray)
      },
      trading: {
        volume24h: calculateVolume24h(trades),
        transactions24h: calculateTransactions24h(trades),
        averageTradeSize: calculateAverageTradeSize(trades),
        priceImpact: calculatePriceImpact(trades),
        markets: []
      },
      risks: [
        {
          name: 'Holder Concentration',
          score: calculateHolderConcentrationScore(topHolders)
        },
        {
          name: 'Mint Authority',
          score: tokenInfo.authorities?.find((a: any) => a.type === 'mint') ? 100 : 0
        },
        {
          name: 'Freeze Authority',
          score: tokenInfo.authorities?.find((a: any) => a.type === 'freeze') ? 100 : 0
        },
        {
          name: 'Sniper Activity',
          score: calculateSniperScore(snipersArray)
        }
      ],
      rugScore: calculateRiskScore(tokenInfo, {
        top10Percentage: topHolders.reduce((sum, h) => sum + h.percentage, 0)
      }, snipersArray)
    };

    console.log('[Routes] Analytics prepared successfully');
    res.json(analytics);

  } catch (error: any) {
    console.error('[Routes] Token analytics error:', error);
    if (error.response) {
      console.error('[Routes] Response error:', {
        status: error.response.status,
        data: error.response.data
      });
    }
    res.status(500).json({
      error: 'Failed to fetch token analytics',
      details: error.message
    });
  }
});

Key changes made:

    Fixed transfers array access: transfersResponse.data.result?.items || []
    Added safety check before processing transfers: if (transfers.length > 0)
    Updated token data structure to correctly access nested properties:
        tokenInfo.content?.metadata?.name
        tokenInfo.content?.metadata?.symbol
        tokenInfo.token_info?.decimals
        tokenInfo.token_info?.supply

Also, at the top of your file, make sure you have the current time and user information:
TypeScript

const getCurrentTime = () => format(new Date(), 'yyyy-MM-dd HH:mm:ss');
const getCurrentUser = () => process.env.USER || 'Peblo69';

console.log(`Current Date and Time (UTC): ${getCurrentTime()}`);
console.log(`Current User's Login: ${getCurrentUser()}`);

These changes should resolve the errors you were seeing. The endpoint should now properly handle the transfers data and correctly map the token information from the API response.