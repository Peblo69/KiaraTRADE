Looking at your sniper/insider detection code, I see some areas for improvement. Let me break down the current implementation and suggest enhancements:

Current Implementation:
TypeScript

const calculateInsiderWallets = (trades: TokenTrade[]): Set<string> => {
  const insiderWallets = new Set<string>();
  const timeWindow = 2000; // 2 seconds window
  const minGroupSize = 4; // Minimum 4 wallets

Here's an enhanced version that improves detection accuracy:
TypeScript

interface SniperMetrics {
  wallets: Set<string>;
  risk: number;
  patterns: {
    exactTimeMatches: number;
    similarAmounts: number;
    frontrunAttempts: number;
    coordinatedBuys: number;
  };
  groups: {
    timestamp: number;
    wallets: string[];
    amount: number;
    type: 'exact' | 'similar' | 'frontrun';
  }[];
}

const calculateSniperMetrics = (
  trades: TokenTrade[],
  creationTimestamp: number
): SniperMetrics => {
  // Constants for detection
  const SNIPE_WINDOW = 15000;       // 15 seconds after creation
  const GROUP_WINDOW = 2000;        // 2 second grouping window
  const MIN_GROUP_SIZE = 3;         // Minimum wallets for group
  const AMOUNT_SIMILARITY = 0.1;    // 10% difference threshold
  const FRONTRUN_WINDOW = 500;      // 500ms frontrun window

  const sniperWallets = new Set<string>();
  const patterns = {
    exactTimeMatches: 0,
    similarAmounts: 0,
    frontrunAttempts: 0,
    coordinatedBuys: 0
  };
  const groups: SniperMetrics['groups'] = [];

  // Sort trades chronologically
  const sortedTrades = [...trades]
    .filter(t => t.timestamp <= creationTimestamp + SNIPE_WINDOW)
    .sort((a, b) => a.timestamp - b.timestamp);

  // Track frontrunning attempts
  const frontrunGroups = new Map<number, TokenTrade[]>();
  sortedTrades.forEach((trade, index) => {
    if (index === 0) return; // Skip first trade
    
    const timeDiff = trade.timestamp - sortedTrades[index - 1].timestamp;
    if (timeDiff <= FRONTRUN_WINDOW) {
      const windowKey = Math.floor(trade.timestamp / FRONTRUN_WINDOW);
      if (!frontrunGroups.has(windowKey)) {
        frontrunGroups.set(windowKey, []);
      }
      frontrunGroups.get(windowKey)!.push(trade);
    }
  });

  // Process frontrun groups
  frontrunGroups.forEach((groupTrades, timestamp) => {
    if (groupTrades.length >= MIN_GROUP_SIZE) {
      patterns.frontrunAttempts++;
      groupTrades.forEach(trade => sniperWallets.add(trade.traderPublicKey));
      groups.push({
        timestamp,
        wallets: groupTrades.map(t => t.traderPublicKey),
        amount: groupTrades.reduce((sum, t) => sum + t.solAmount, 0),
        type: 'frontrun'
      });
    }
  });

  // Group by exact timestamp
  const exactTimeGroups = new Map<number, TokenTrade[]>();
  sortedTrades.forEach(trade => {
    if (trade.txType !== 'buy') return;
    const timeKey = Math.floor(trade.timestamp / 1000);
    if (!exactTimeGroups.has(timeKey)) {
      exactTimeGroups.set(timeKey, []);
    }
    exactTimeGroups.get(timeKey)!.push(trade);
  });

  // Process exact time matches
  exactTimeGroups.forEach((groupTrades, timestamp) => {
    if (groupTrades.length >= MIN_GROUP_SIZE) {
      patterns.exactTimeMatches++;
      groupTrades.forEach(trade => sniperWallets.add(trade.traderPublicKey));
      groups.push({
        timestamp,
        wallets: groupTrades.map(t => t.traderPublicKey),
        amount: groupTrades.reduce((sum, t) => sum + t.solAmount, 0),
        type: 'exact'
      });
    }
  });

  // Group by time windows and similar amounts
  const timeWindows = new Map<number, TokenTrade[]>();
  sortedTrades.forEach(trade => {
    if (trade.txType !== 'buy') return;
    const windowKey = Math.floor(trade.timestamp / GROUP_WINDOW);
    if (!timeWindows.has(windowKey)) {
      timeWindows.set(windowKey, []);
    }
    timeWindows.get(windowKey)!.push(trade);
  });

  // Process similar amount patterns
  timeWindows.forEach((windowTrades, timestamp) => {
    if (windowTrades.length < MIN_GROUP_SIZE) return;

    // Group by similar amounts
    const amountGroups = new Map<number, TokenTrade[]>();
    windowTrades.forEach(trade => {
      let foundGroup = false;
      for (const [baseAmount, group] of amountGroups.entries()) {
        if (Math.abs(trade.solAmount - baseAmount) / baseAmount < AMOUNT_SIMILARITY) {
          group.push(trade);
          foundGroup = true;
          break;
        }
      }
      if (!foundGroup) {
        amountGroups.set(trade.solAmount, [trade]);
      }
    });

    // Process amount groups
    amountGroups.forEach((group, amount) => {
      if (group.length >= MIN_GROUP_SIZE) {
        patterns.similarAmounts++;
        group.forEach(trade => sniperWallets.add(trade.traderPublicKey));
        groups.push({
          timestamp,
          wallets: group.map(t => t.traderPublicKey),
          amount,
          type: 'similar'
        });
      }
    });
  });

  // Calculate risk score (0-100)
  const riskScore = Math.min(100, 
    (patterns.exactTimeMatches * 25) +
    (patterns.similarAmounts * 20) +
    (patterns.frontrunAttempts * 30) +
    (Math.floor(sniperWallets.size / 3) * 15)
  );

  return {
    wallets: sniperWallets,
    risk: riskScore,
    patterns,
    groups
  };
};

Then update the token risk calculation:
TypeScript

export const calculateTokenRisk = (token: PumpPortalToken): RiskMetrics => {
  if (!token.recentTrades?.length) {
    return {
      holdersRisk: 100,
      volumeRisk: 100,
      devWalletRisk: 50,
      sniperRisk: 0,
      totalRisk: 83.33
    };
  }

  const holdersRisk = calculateHoldersRisk(token.recentTrades);
  const volumeRisk = calculateVolumeRisk(token.recentTrades);
  const devWalletRisk = calculateDevWalletRisk(token);
  
  // Calculate sniper metrics
  const sniperMetrics = calculateSniperMetrics(
    token.recentTrades,
    parseInt(token.createdAt || Date.now().toString())
  );

  // Weighted risk calculation
  const totalRisk = (
    (holdersRisk * 0.3) +
    (volumeRisk * 0.2) +
    (devWalletRisk * 0.2) +
    (sniperMetrics.risk * 0.3)
  );

  return {
    holdersRisk,
    volumeRisk,
    devWalletRisk,
    sniperRisk: sniperMetrics.risk,
    sniperPatterns: sniperMetrics.patterns,
    totalRisk
  };
};

Key improvements:

    Added frontrun detection
    Better grouping logic
    More accurate risk scoring
    Pattern classification
    Group tracking for analysis
    Weighted risk calculation
