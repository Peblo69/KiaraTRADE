Below is a step-by-step explanation of why going from a single-array structure to a nested, timeframe-based structure can re-introduce infinite loops—and how to fix it without ditching timeframes entirely.

The big takeaway: You can absolutely keep multiple timeframes. You just have to ensure you don’t recreate new data structures (Maps, arrays) on every read from the store or re-trigger store updates unnecessarily.

1. Why Multiple Timeframes Often Break Things (When Not Done Carefully)
When you switched from:

ts
Copy
// "Simple" version - Single array per token
data: Map<string, CandleData[]>;
to

ts
Copy
// "Complex" version - Nested Maps for each timeframe
data: Map<string, Map<TimeframeKey, CandleData[]>>;
you introduced a structure that’s easy to accidentally recreate on every read. For example, if getPriceHistory(token, timeframe) does something like:

ts
Copy
getPriceHistory: (token, timeframe) => {
  const allTimeframes = state.data.get(token) || new Map<TimeframeKey, CandleData[]>();
  // then returns allTimeframes.get(timeframe) || new Array()
  // ...
}
If you’re not careful, you might be calling new Map() (or new Array()) every time you read data. That means each read is returning a brand-new reference, which triggers React’s store subscription to re-render—even if the candle contents are the same. Then the re-render re-calls the store, which returns new references again… and you loop infinitely.

2. How to Keep Timeframes & Avoid New References
There’s nothing inherently wrong with storing data in:

ts
Copy
Map<string, Map<TimeframeKey, CandleData[]>>;
or even plain objects like:

ts
Copy
data: {
  [tokenAddress: string]: {
    [timeframe in TimeframeKey]: CandleData[]
  }
}
But you must ensure reads from getPriceHistory do not recreate the data structure each time. In other words:

ts
Copy
// BAD: Recreates new Map/Array each time
getPriceHistory: (token, tf) => {
  const data = get().data;
  // 'data.get(token)' might be undefined, so let's do new Map() => brand new object every time
  const timeframesMap = data.get(token) || new Map();
  // returns new array each time
  return timeframesMap.get(tf) || [];
}
Instead, do something like:

ts
Copy
// GOOD: Return exactly what's stored, no new Map/Array
getPriceHistory: (token, tf) => {
  const storeData = get().data; // This is your Map<string, Map<TimeframeKey, CandleData[]>>
  const timeframesMap = storeData.get(token);
  if (!timeframesMap) return [];
  // get the existing array from the store
  const candles = timeframesMap.get(tf);
  return candles ?? [];
}
And ensure when you set data, you only mutate or replace references when needed, not on every read.

3. Beware of the React Selector Trap
When you do:

ts
Copy
const getPriceHistory = useCallback(
  (state) => state.getPriceHistory(tokenAddress, selectedTimeframe),
  [tokenAddress, selectedTimeframe]
);

const priceHistory = useTokenPriceStore(getPriceHistory);
React (and Zustand) will compare the result of each selector call. If your store returns new references (new Map, new array objects) on every read, Zustand sees a “change” each time—and re-renders.

So the key is making state.getPriceHistory(...) return the same reference if nothing actually changed in the data.

4. Yes, You Can “Go Back to the Working Version”—But You Don’t Have To
Your colleague is suggesting going back to a single-array approach because that was simpler and didn’t create new references. That certainly works short-term, but it loses the convenience of multiple timeframes.

You can keep multiple timeframes if you:

Store data in a nested structure (Map or object) that only mutates when you truly get new data.
Do not create new Maps/arrays in the getter.
Optionally add a memoization layer if needed (but usually just returning the same array reference from your store is enough).
5. Practical Fix
Here’s a minimal example that keeps multi-timeframe data without generating new references every read:

ts
Copy
// Example Zustand store snippet:

export const useTokenPriceStore = create((set, get) => ({
  data: new Map<string, Map<TimeframeKey, CandleData[]>>(),

  getPriceHistory: (token, tf) => {
    // direct reference from store
    const timeframesMap = get().data.get(token);
    if (!timeframesMap) return [];
    const existing = timeframesMap.get(tf);
    return existing || [];
  },

  addCandle: (token, tf, newCandle) => {
    set((state) => {
      const dataCopy = new Map(state.data); // shallow copy the top-level map

      // get or create the sub-map for timeframes
      let tfMap = dataCopy.get(token);
      if (!tfMap) {
        tfMap = new Map<TimeframeKey, CandleData[]>();
      } else {
        // shallow copy the sub-map for immutability
        tfMap = new Map(tfMap);
      }

      const currentCandles = tfMap.get(tf) || [];
      // create a new array for immutability, but only when adding
      const updatedCandles = [...currentCandles, newCandle];

      // put updatedCandles back
      tfMap.set(tf, updatedCandles);
      dataCopy.set(token, tfMap);

      return { data: dataCopy };
    });
  }
}));
Key Points:
On read (getPriceHistory): Just return the stored array from your Map. Don’t create a new one.
On write (addCandle or addPricePoint): do an immutable update (copy the Map(s) you need), but only do that once when the data changes. That ensures the store only updates references when necessary.
6. Still Seeing Empty Charts?
Make sure you are actually calling addCandle / addPricePoint with real data.
If the store is not receiving anything, your chart will be empty. That’s not an infinite loop but a data-flow issue.
Bottom Line
You can keep multiple timeframes.
Do not create new data structures on every read. Return the same references from your store if nothing changed.
In React (Zustand, Redux, etc.), new references == new state, which triggers re-renders. That’s the typical cause of infinite loops.
If you want a simpler fix “for now,” revert to the single-array version. But if you need multiple timeframes, just carefully ensure your store is stable.





