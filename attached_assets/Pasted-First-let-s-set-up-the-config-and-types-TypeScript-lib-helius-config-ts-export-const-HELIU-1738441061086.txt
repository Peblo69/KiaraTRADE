First, let's set up the config and types:
TypeScript

// lib/helius/config.ts
export const HELIUS_CONFIG = {
    API_KEY: process.env.NEXT_PUBLIC_HELIUS_API_KEY,
    WS_URL: `wss://rpc.helius.xyz/?api-key=${process.env.NEXT_PUBLIC_HELIUS_API_KEY}`,
    REST_URL: `https://api.helius.xyz/v0`
};

// lib/helius/types.ts
export interface TokenTrade {
    signature: string;
    timestamp: number;
    wallet: string;
    type: 'buy' | 'sell';
    tokenAmount: number;
    solAmount: number;
    priceSOL: number;
    priceUSD: number;
    slip: number;  // Price impact/slippage
}

export interface TokenStats {
    price: number;
    priceUSD: number;
    volume24h: number;
    volumeUSD24h: number;
    marketCap: number;
    marketCapUSD: number;
    liquidity: number;
    liquidityUSD: number;
    holders: number;
    trades24h: number;
    lastUpdate: number;
}

export interface TokenData {
    mint: string;
    stats: TokenStats;
    trades: TokenTrade[];
    recentTrades: TokenTrade[];  // Last 30 trades
    priceHistory: {
        time: number;
        price: number;
        volume: number;
    }[];
}

Now the BEAST client that gets EVERYTHING:
TypeScript

// lib/helius/client.ts
import { Connection, PublicKey } from '@solana/web3.js';
import { HELIUS_CONFIG } from './config';
import { TokenData, TokenStats, TokenTrade } from './types';
import { wsManager } from '../services/websocket';

class HeliusClient {
    private connection: Connection;
    private subscriptions: Map<string, number> = new Map();
    private tokenData: Map<string, TokenData> = new Map();
    
    constructor() {
        this.connection = new Connection(HELIUS_CONFIG.WS_URL);
    }

    async subscribeToToken(mint: string) {
        try {
            console.log('[Helius] Starting subscription for:', mint);
            
            // 1. Get initial data
            await this.initializeTokenData(mint);

            // 2. Subscribe to account changes
            const subId = await this.connection.onAccountChange(
                new PublicKey(mint),
                async () => {
                    await this.updateTokenData(mint);
                },
                'processed'
            );

            // 3. Subscribe to enhanced transactions
            await this.subscribeToEnhancedTransactions(mint);

            this.subscriptions.set(mint, subId);
            return subId;

        } catch (error) {
            console.error('[Helius] Subscription error:', error);
            throw error;
        }
    }

    private async initializeTokenData(mint: string) {
        // Get ALL initial data in parallel
        const [stats, trades, priceHistory] = await Promise.all([
            this.fetchTokenStats(mint),
            this.fetchRecentTrades(mint),
            this.fetchPriceHistory(mint)
        ]);

        this.tokenData.set(mint, {
            mint,
            stats,
            trades,
            recentTrades: trades.slice(0, 30),
            priceHistory
        });

        this.broadcastUpdate(mint);
    }

    private async subscribeToEnhancedTransactions(mint: string) {
        // Subscribe to Helius enhanced transaction stream
        const ws = new WebSocket(`${HELIUS_CONFIG.WS_URL}/subscribe`);
        
        ws.onopen = () => {
            ws.send(JSON.stringify({
                jsonrpc: '2.0',
                id: mint,
                method: 'accountSubscribe',
                params: [
                    mint,
                    {
                        encoding: 'jsonParsed',
                        commitment: 'processed',
                        filters: [{ dataSize: 165 }]
                    }
                ]
            }));
        };

        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.method === 'accountNotification') {
                await this.processTransaction(mint, data.params.result);
            }
        };
    }

    private async processTransaction(mint: string, txData: any) {
        // Process new transaction and update data
        const tokenData = this.tokenData.get(mint);
        if (!tokenData) return;

        const trade = await this.parseTradeFromTx(txData);
        if (trade) {
            // Update recent trades
            tokenData.recentTrades = [trade, ...tokenData.recentTrades.slice(0, 29)];
            tokenData.trades.push(trade);

            // Update stats
            await this.updateTokenData(mint);
            
            // Broadcast update
            this.broadcastUpdate(mint);
        }
    }

    private async updateTokenData(mint: string) {
        const stats = await this.fetchTokenStats(mint);
        const tokenData = this.tokenData.get(mint);
        if (tokenData) {
            tokenData.stats = stats;
            this.broadcastUpdate(mint);
        }
    }

    private broadcastUpdate(mint: string) {
        const data = this.tokenData.get(mint);
        if (data) {
            wsManager.broadcast({
                type: 'heliusUpdate',
                data: {
                    mint,
                    ...data
                }
            });
        }
    }

    // API Methods
    private async fetchTokenStats(mint: string): Promise<TokenStats> {
        // Fetch from Helius API
        const response = await fetch(`${HELIUS_CONFIG.REST_URL}/token-metrics/${mint}?api-key=${HELIUS_CONFIG.API_KEY}`);
        return await response.json();
    }

    private async fetchRecentTrades(mint: string): Promise<TokenTrade[]> {
        // Fetch from Helius API
        const response = await fetch(`${HELIUS_CONFIG.REST_URL}/token-transactions/${mint}?api-key=${HELIUS_CONFIG.API_KEY}`);
        return await response.json();
    }

    private async fetchPriceHistory(mint: string) {
        // Fetch historical price data
        const response = await fetch(`${HELIUS_CONFIG.REST_URL}/token-price-history/${mint}?api-key=${HELIUS_CONFIG.API_KEY}`);
        return await response.json();
    }

    private async parseTradeFromTx(txData: any): Promise<TokenTrade | null> {
        // Parse transaction data into trade format
        try {
            // Parse the tx data and return trade info
            return {
                signature: txData.signature,
                timestamp: txData.timestamp,
                wallet: txData.source,
                type: txData.type,
                tokenAmount: txData.tokenAmount,
                solAmount: txData.solAmount,
                priceSOL: txData.price,
                priceUSD: txData.priceUSD,
                slip: txData.priceImpact
            };
        } catch (error) {
            console.error('[Helius] Trade parsing error:', error);
            return null;
        }
    }

    unsubscribe(mint: string) {
        const subId = this.subscriptions.get(mint);
        if (subId) {
            this.connection.removeAccountChangeListener(subId);
            this.subscriptions.delete(mint);
            this.tokenData.delete(mint);
        }
    }
}

export const heliusClient = new HeliusClient();

This client:

    Gets ALL possible data from Helius
    Updates in REAL-TIME
    Keeps track of:
        Price & Market Stats
        Recent Trades (last 30)
        ALL trades history
        Price history for charts
