STEPS 1-3 COMBINED: Helius Setup + Combined Store + UI Updates

    First, create these two files:

lib/helius-websocket.ts:
TypeScript

// [Previous Helius WebSocket code remains the same]

// Add these new helper functions
export function setupTokenSubscription(tokenAddress: string) {
  // Subscribe to both data sources
  usePumpPortalStore.getState().addToViewedTokens(tokenAddress);
  useHeliusStore.getState().subscribeToToken(tokenAddress);
}

export function getCombinedTokenData(tokenAddress: string) {
  const pumpData = usePumpPortalStore.getState().getToken(tokenAddress);
  const heliusData = useHeliusStore.getState().tokenData[tokenAddress];

  return {
    ...pumpData,
    realTimeData: heliusData
  };
}

    Update your TradingChart.tsx:

TypeScript

import { FC, useEffect } from 'react';
import { usePumpPortalStore } from '@/lib/pump-portal-websocket';
import { useHeliusStore, setupTokenSubscription } from '@/lib/helius-websocket';

const TradingChart: FC<{ tokenAddress: string }> = ({ tokenAddress }) => {
  // Get data from both sources
  const token = usePumpPortalStore(state => state.getToken(tokenAddress));
  const realTimeData = useHeliusStore(state => state.tokenData[tokenAddress]);

  useEffect(() => {
    if (tokenAddress) {
      setupTokenSubscription(tokenAddress);
    }
  }, [tokenAddress]);

  const candleData = useMemo(() => {
    if (!token?.recentTrades?.length) return [];

    // Combine historical trades from PumpPortal
    const historicalTrades = token.recentTrades;
    
    // With real-time trades from Helius
    const realtimeTrades = realTimeData?.trades || [];
    
    const allTrades = [
      ...historicalTrades,
      ...realtimeTrades
    ].sort((a, b) => b.timestamp - a.timestamp);

    // Group into candles
    return groupTradesIntoCandles(allTrades, selectedInterval);
  }, [token?.recentTrades, realTimeData?.trades, selectedInterval]);

  // Rest of your chart code...
};

    Update TokenMarketStats.tsx:

TypeScript

import { FC } from 'react';
import { usePumpPortalStore } from '@/lib/pump-portal-websocket';
import { useHeliusStore } from '@/lib/helius-websocket';

const TokenMarketStats: FC<{ tokenAddress: string }> = ({ tokenAddress }) => {
  // Get base token info from PumpPortal
  const token = usePumpPortalStore(state => state.getToken(tokenAddress));
  
  // Get real-time updates from Helius
  const realTimeData = useHeliusStore(state => state.tokenData[tokenAddress]);

  // Combine the data
  const currentPrice = realTimeData?.lastPrice || token?.priceInUsd;
  const volume24h = realTimeData?.volume24h || token?.volume24h;

  return (
    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
      <StatCard
        title="Price"
        value={`$${currentPrice?.toFixed(8) || '0.00'}`}
        change={calculatePriceChange(token, realTimeData)}
      />
      <StatCard
        title="24h Volume"
        value={`$${volume24h?.toLocaleString() || '0.00'}`}
      />
      {/* Other stats... */}
    </div>
  );
};

    Add this to your main page:

TypeScript

// pages/token/[address].tsx
import { useEffect } from 'react';
import { useRouter } from 'next/router';
import { setupTokenSubscription } from '@/lib/helius-websocket';
import TradingChart from '@/components/TradingChart';
import TokenMarketStats from '@/components/TokenMarketStats';

export default function TokenPage() {
  const router = useRouter();
  const { address } = router.query;

  useEffect(() => {
    if (address) {
      setupTokenSubscription(address as string);
    }
  }, [address]);

  return (
    <div className="space-y-4">
      <TokenMarketStats tokenAddress={address as string} />
      <TradingChart tokenAddress={address as string} />
    </div>
  );
}

This setup:

    Uses Helius for real-time data
    Keeps PumpPortal for token info
    Combines them in the UI
    Updates everything in real-time
