// Add token analytics endpoint
app.get('/api/token-analytics/:mint', async (req, res) => {
  try {
    const { mint } = req.params;
    console.log(`[Routes] Getting token analytics for ${mint}`);

    // Using correct Helius API methods according to their documentation
    const [tokenInfoResponse, balancesResponse, txResponse] = await Promise.all([
      // Get Token Metadata
      axios.post(HELIUS_RPC_URL, {
        jsonrpc: '2.0',
        id: 'token-info',
        method: 'getAsset',  // Changed from getToken to getAsset
        params: {
          id: mint
        }
      }),

      // Get Token Balances
      axios.post(HELIUS_RPC_URL, {
        jsonrpc: '2.0',
        id: 'balances-request',
        method: 'getAssetsByOwner', // Changed from getTokenHolders to getAssetsByOwner
        params: {
          ownerAddress: mint,
          page: 1,
          limit: 100
        }
      }),

      // Get Token Transactions
      axios.post(HELIUS_RPC_URL, {
        jsonrpc: '2.0',
        id: 'tx-request',
        method: 'searchAssets',  // Changed to searchAssets
        params: {
          ownerAddress: mint,
          compressed: true,
          page: 1,
          limit: 100
        }
      })
    ]);

    console.log('[DEBUG] Token Info Response:', tokenInfoResponse.data);
    console.log('[DEBUG] Balances Response:', balancesResponse.data);
    console.log('[DEBUG] Transactions Response:', txResponse.data);

    // Extract token information
    const tokenInfo = tokenInfoResponse.data.result;
    const mintAuthority = tokenInfo?.authorities?.[0]?.address || null;
    const freezeAuthority = tokenInfo?.authorities?.[1]?.address || null;

    // Calculate holder distribution
    const holders = balancesResponse.data.result || [];
    const totalSupply = tokenInfo.supply || 0;

    const holdersBySize = holders
      .filter(h => h.ownership?.owner) // Make sure we have valid holder data
      .map(h => ({
        address: h.ownership.owner,
        amount: h.ownership.amount || 0,
        pct: ((h.ownership.amount || 0) / totalSupply) * 100
      }))
      .sort((a, b) => b.amount - a.amount);

    // Analyze transactions
    const transactions = txResponse.data.result || [];
    const creationTime = transactions[transactions.length - 1]?.timestamp || Date.now();

    // Additional alternative method to get detailed token data
    const detailedTokenData = await axios.post(HELIUS_RPC_URL, {
      jsonrpc: '2.0',
      id: 'detailed-token',
      method: 'getAssetsByGroup',
      params: {
        groupKey: 'collection',
        groupValue: mint,
        page: 1,
        limit: 1000
      }
    });

    // Prepare analytics response
    const analytics = {
      token: {
        address: mint,
        name: tokenInfo.name || 'Unknown',
        symbol: tokenInfo.symbol || 'Unknown',
        decimals: tokenInfo.decimals || 0,
        totalSupply: totalSupply,
        mintAuthority: mintAuthority,
        freezeAuthority: freezeAuthority
      },
      holders: {
        total: holdersBySize.length,
        distribution: holdersBySize.slice(0, 10), // Top 10 holders
        averageBalance: totalSupply / (holdersBySize.length || 1)
      },
      activity: {
        transactions: transactions.length,
        uniqueHolders: new Set(holdersBySize.map(h => h.address)).size,
        creationTime: creationTime
      }
    };

    console.log('[Routes] Analytics response prepared:', {
      hasTokenInfo: !!analytics.token,
      holdersCount: analytics.holders.total,
      transactionCount: analytics.activity.transactions
    });

    res.json(analytics);

  } catch (error: any) {
    console.error('[Routes] Token analytics error:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status
    });
    res.status(500).json({
      error: 'Failed to fetch token analytics',
      details: error.message
    });
  }
});